<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Runner - Fluid Crowd (3D Stickmen)</title>
<style>
  body { margin:0; display:flex; align-items:center; justify-content:center; height:100vh; background:#071020; overflow:hidden; }
  canvas { border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,0.6); }
</style>
</head>
<body>
<canvas id="game" width="420" height="720"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- Utility ---
function clamp(value, min, max) { return Math.max(min, Math.min(max, value)); }
function lerp(a, b, t){ return a + (b-a)*t; }

// --- Config ---
let running=false;
const roadWidth=260;
const horizon=220;
const segmentHeight=44;
const roadScroll=0.6;
const laneCount=3;
const maxPlayers=120;
const minZ=-20;
const maxZ=80;
let formationInput=0;
const centerXScreen = canvas.width/2;

// --- Road ---
let roadSegments=[];
function initRoad(){
  roadSegments=[];
  let y=canvas.height+segmentHeight;
  while(y>horizon-segmentHeight){ roadSegments.push({y}); y-=segmentHeight; }
}
function updateRoad(){
  for(let seg of roadSegments) seg.y+=roadScroll;
  while(roadSegments.length && roadSegments[0].y>canvas.height+segmentHeight) roadSegments.shift();
  while(roadSegments.length==0 || roadSegments[roadSegments.length-1].y>horizon-segmentHeight*0.25){
    const topY=roadSegments.length?roadSegments[roadSegments.length-1].y-segmentHeight:canvas.height+segmentHeight;
    roadSegments.push({y:topY});
  }
}
function drawRoad(){
  for(let s of roadSegments){
    const t=(s.y-canvas.height)/(horizon-canvas.height);
    const w0=roadWidth*(1-t*0.9);
    const w1=roadWidth*(1-(t+segmentHeight/(canvas.height-horizon))*0.9);
    const y0=s.y, y1=s.y-segmentHeight;
    ctx.fillStyle='#444'; ctx.beginPath();
    ctx.moveTo(centerXScreen-w0/2,y0); ctx.lineTo(centerXScreen+w0/2,y0);
    ctx.lineTo(centerXScreen+w1/2,y1); ctx.lineTo(centerXScreen-w1/2,y1); ctx.closePath(); ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=2; ctx.setLineDash([10,14]);
    for(let lane=1; lane<laneCount; lane++){
      const lx0=centerXScreen-w0/2+(w0/laneCount)*lane;
      const lx1=centerXScreen-w1/2+(w1/laneCount)*lane;
      ctx.beginPath(); ctx.moveTo(lx0,y0); ctx.lineTo(lx1,y1); ctx.stroke();
    }
    ctx.setLineDash([]);
  }
}

// --- Players ---
let players=[];
function createPlayer(x=centerXScreen,z=10){
  const blueShade = 180 + Math.floor(Math.random()*50);
  return { 
    x, z, phase: Math.random()*Math.PI*2, bobPhase: Math.random()*Math.PI*2,
    skin:`rgb(${Math.floor(Math.random()*55+200)},${Math.floor(Math.random()*60+160)},${Math.floor(Math.random()*50+140)})`,
    shirt:`rgb(50,${blueShade},230)`, lastWallId:-1
  };
}
players=[createPlayer()];

function updatePlayers(){
  for(let i=0;i<players.length;i++){
    const p=players[i];
    p.z=clamp(p.z+roadScroll,minZ,maxZ);
    let sepX=0, sepZ=0;
    for(let j=0;j<players.length;j++){ 
      if(i===j) continue; 
      const o=players[j]; 
      const dx=o.x-p.x; 
      const dz=o.z-p.z; 
      const dist=Math.sqrt(dx*dx+dz*dz);
      if(dist<32){
        const push=0.02*(32-dist);
        sepX -= dx/dist * push;
        sepZ -= dz/dist * push;
      }
    }
    p.x += formationInput*0.05 + sepX;
    p.z += sepZ;
    const halfRoad=roadWidth/2-18;
    p.x=clamp(p.x,centerXScreen-halfRoad,centerXScreen+halfRoad);
    p.z=clamp(p.z,minZ,maxZ);
  }
}

function drawPlayers(){
  for(let p of players){
    const x=p.x, y=canvas.height-120-p.z;
    const headBob = Math.sin(Date.now()/200 + p.bobPhase)*2;
    ctx.fillStyle=p.skin; ctx.beginPath(); ctx.arc(x,y-14+headBob,6,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=p.shirt; ctx.fillRect(x-6,y-8+headBob,12,12);
    ctx.strokeStyle='black'; ctx.beginPath(); ctx.moveTo(x-6,y+4+headBob); ctx.lineTo(x-6,y+14+headBob);
    ctx.moveTo(x+6,y+4+headBob); ctx.lineTo(x+6,y+14+headBob); ctx.stroke();
  }
}

// --- Wall ---
let wall={y:horizon+60,active:false,width:120,height:120,id:0};
let lastWallSpawn=Date.now();
const wallInterval=5000;
function handleWall(){
  const now=Date.now();
  if(now-lastWallSpawn>wallInterval){ lastWallSpawn=now; wall.y=horizon; wall.active=true; wall.id++; }
  if(wall.active) wall.y+=roadScroll;
  if(wall.active){ ctx.fillStyle='blue'; ctx.fillRect(centerXScreen-wall.width/2,wall.y,wall.width,wall.height); ctx.fillStyle='white'; ctx.font='28px sans-serif'; ctx.textAlign='center'; ctx.fillText('2X',centerXScreen,wall.y+wall.height/2+10); }
  for(let i=players.length-1;i>=0;i--){
    const p=players[i];
    const playerY=canvas.height-120-p.z;
    if(wall.active && p.lastWallId!==wall.id && playerY>wall.y && playerY<wall.y+wall.height){
      if(players.length<maxPlayers){
        players.push({...p, x:clamp(p.x+Math.random()*16-8, centerXScreen-roadWidth/2+10, centerXScreen+roadWidth/2-10), lastWallId:wall.id, bobPhase: Math.random()*Math.PI*2});
        p.lastWallId=wall.id;
      }
    }
  }
}

// --- Background ---
function drawBackground(){
  if(!running){ ctx.fillStyle='#3b7ddd'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='white'; ctx.font='40px sans-serif'; ctx.textAlign='center'; ctx.fillText('Last War â€” Runner',centerXScreen,canvas.height/2-24);
    ctx.font='20px sans-serif'; ctx.fillText('Click to Start',centerXScreen,canvas.height/2+16); return; }
  const grad = ctx.createLinearGradient(0,0,0,canvas.height);
  grad.addColorStop(0,'#3d3d3d'); grad.addColorStop(1,'#111'); ctx.fillStyle=grad; ctx.fillRect(0,0,canvas.width,canvas.height);
}

// --- Game Loop ---
function gameLoop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground();
  if(!running) return;
  updateRoad(); drawRoad();
  updatePlayers(); drawPlayers();
  handleWall();
  requestAnimationFrame(gameLoop);
}

canvas.addEventListener('click',()=>{ running=true; initRoad(); gameLoop(); });
window.addEventListener('keydown',e=>{ if(e.key==='ArrowLeft') formationInput=-12; if(e.key==='ArrowRight') formationInput=12; });
window.addEventListener('keyup',e=>{ if(e.key==='ArrowLeft'||e.key==='ArrowRight') formationInput=0; });

drawBackground();
</script>
</body>
</html>
