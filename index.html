<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Runner - Fluid Crowd (3D Stickmen)</title>
<style>
  body { margin:0; display:flex; align-items:center; justify-content:center; height:100vh; background:#071020; overflow:hidden; }
  canvas { border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,0.6); }
</style>
</head>
<body>
<canvas id="game" width="420" height="720"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- Config ---
let tick = 0;
let running = false;
const roadWidth = 260;
const playerSpeed = 3;
const horizon = 220;
const segmentHeight = 44;
const roadScroll = 1.6;
const laneCount = 3;
const maxPlayers = 120;

// Crowd parameters
const minZ = -20;
const maxZ = 80;
const forwardSpeed = 0.2;

let roadSegments = [];
let players = [];
let formationInput = 0;

// Wall setup
let wall = { y: horizon + 60, active: false, width:120, height:120, id:0 };
let lastWallSpawn = Date.now();
const wallInterval = 5000;

// Utility
function rand(a,b){return a + Math.random()*(b-a);}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function lerp(a,b,t){return a + (b-a)*t;}

function createPlayer(x = 0, z = 10){
  return { x, z, vx:0, vz:0, phase: Math.random()*Math.PI*2, skin: `rgb(${Math.floor(rand(220,255))},${Math.floor(rand(170,220))},${Math.floor(rand(140,190))})`, shirtA: rand(0.6,0.9), lastWallId: -1 };
}

players = [createPlayer(0,10)];

// --- Road functions ---
function initRoad(){
  roadSegments = [];
  let y = canvas.height - segmentHeight/2;
  while(y > horizon - segmentHeight) {
    roadSegments.push({y});
    y -= segmentHeight;
  }
}

function drawBackground(){
  if(!running){
    ctx.fillStyle='#3b7ddd'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='white'; ctx.font='40px sans-serif'; ctx.textAlign='center';
    ctx.fillText('Last War â€” Runner', canvas.width/2, canvas.height/2 - 24);
    ctx.font='20px sans-serif'; ctx.fillText('Click to Start', canvas.width/2, canvas.height/2 + 16);
    return;
  }
  const g = ctx.createLinearGradient(0,0,0,horizon);
  g.addColorStop(0,'#2b1a1a'); g.addColorStop(1,'#444');
  ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,horizon);
  ctx.fillStyle='#151515';
  const ruins = [40,120,200,280,360];
  for(let i=0;i<ruins.length;i++){
    const w = 24 + (i%2?Math.random()*30:Math.random()*10);
    const h = 30 + Math.random()*70;
    ctx.fillRect(ruins[i], horizon - h, w, h);
  }
  ctx.fillStyle='#1f1f1f'; ctx.fillRect(0,horizon,canvas.width,canvas.height-horizon);
}

function drawRoad(){
  for(let s of roadSegments){
    const t = (s.y - canvas.height) / (horizon - canvas.height);
    const w0 = roadWidth * (1 - t*0.9);
    const w1 = roadWidth * (1 - (t + segmentHeight/(canvas.height-horizon))*0.9);
    const y0 = s.y; const y1 = s.y - segmentHeight;
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.moveTo(canvas.width/2 - w0/2, y0);
    ctx.lineTo(canvas.width/2 + w0/2, y0);
    ctx.lineTo(canvas.width/2 + w1/2, y1);
    ctx.lineTo(canvas.width/2 - w1/2, y1);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth = 2; ctx.setLineDash([10,14]);
    for(let lane=1; lane<laneCount; lane++){
      const lx0 = canvas.width/2 - w0/2 + (w0/laneCount)*lane;
      const lx1 = canvas.width/2 - w1/2 + (w1/laneCount)*lane;
      ctx.beginPath(); ctx.moveTo(lx0,y0); ctx.lineTo(lx1,y1); ctx.stroke();
    }
    ctx.setLineDash([]);
  }
}

function updateRoad(){
  for(let seg of roadSegments) seg.y += roadScroll;
  while(roadSegments.length && roadSegments[0].y > canvas.height + segmentHeight) roadSegments.shift();
  while(roadSegments.length==0 || roadSegments[roadSegments.length-1].y > horizon - segmentHeight*0.25){
    const topY = (roadSegments.length? roadSegments[roadSegments.length-1].y - segmentHeight : canvas.height);
    roadSegments.push({y: topY});
  }
}

// --- Crowd (fluid) behavior ---
function updatePlayers(){
  const avgX = players.reduce((s,p)=>s+p.x,0)/players.length;
  const targetCenterX = lerp(avgX, formationInput ? (avgX + formationInput) : avgX, 0.25);
  for(let i=0;i<players.length;i++){
    const p = players[i];
    p.z = clamp(p.z + (0.08 + Math.random()*0.02), minZ, maxZ);
    let separationX=0, alignmentX=0, cohesionX=0, countNearby=0;
    for(let j=0;j<players.length;j++){ if(i===j) continue; const o=players[j]; const dx=o.x-p.x; const dz=o.z-p.z; const dist=Math.sqrt(dx*dx+dz*dz); if(dist<48){ if(dist>0) separationX -= (dx/dist)*(48-dist)*0.02; alignmentX+=o.x; cohesionX+=o.x; countNearby++; } }
    if(countNearby>0){ alignmentX/=countNearby; cohesionX/=countNearby; }
    const wobble=(Math.random()-0.5)*0.6;
    const targetX = lerp(p.x, avgX + (cohesionX? (cohesionX - p.x)*0.02 : 0), 0.12);
    p.x += separationX + (alignmentX? (alignmentX - p.x)*0.01:0) + wobble;
    p.x = lerp(p.x, targetX, 0.06);
    const halfRoad = roadWidth/2 - 18;
    const worldLeft = canvas.width/2 - halfRoad;
    const worldRight = canvas.width/2 + halfRoad;
    p.x = clamp(p.x, worldLeft, worldRight);
    p.phase += 0.12 + Math.random()*0.02;
  }
  formationInput = 0;
}

// --- Wall handling ---
function handleWall(){
  const now = Date.now();
  if(now - lastWallSpawn > wallInterval){ lastWallSpawn=now; wall.y=horizon; wall.active=true; wall.id++; }
  if(wall.active) wall.y += roadScroll;
  if(running && wall.active){ ctx.fillStyle='rgba(15,100,230,1)'; const wx=canvas.width/2-wall.width/2,wy=wall.y; ctx.fillRect(wx,wy,wall.width,wall.height); ctx.fillStyle='white'; ctx.font='28px sans-serif'; ctx.textAlign='center'; ctx.fillText('2X', canvas.width/2, wall.y + wall.height/2 +10); }
  for(let i=players.length-1;i>=0;i--){ const p=players[i]; const playerScreenY = canvas.height-120-p.z; const wx=canvas.width/2-wall.width/2,wy=wall.y; if(wall.active && p.lastWallId!==wall.id && playerScreenY>wy && playerScreenY<wy+wall.height){ if(players.length<maxPlayers){ const left={...p,x:clamp(p.x-8, canvas.width/2-roadWidth/2+10, canvas.width/2+road
